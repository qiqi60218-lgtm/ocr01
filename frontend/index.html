<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DocVision AI - 智能文档识别系统</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- Chart.js temporarily disabled for syntax error isolation -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#64748b',
                        accent: '#0ea5e9',
                        dark: '#0f172a',
                        light: '#f8fafc'
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .transition-all-300 {
                transition: all 300ms ease-in-out;
            }
            .backdrop-blur {
                backdrop-filter: blur(8px);
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-50 to-slate-100 min-h-screen font-inter text-slate-800 overflow-x-hidden">
    <!-- 导航栏 -->
    <nav id="navbar" class="fixed top-0 w-full z-50 transition-all duration-300 bg-white/90 backdrop-blur shadow-sm">
        <div class="container mx-auto px-4 py-3 flex items-center justify-between">
            <div class="flex items-center space-x-2">
                <i class="fa fa-file-text-o text-2xl text-primary"></i>
                <h1 class="text-xl font-bold bg-gradient-to-r from-primary to-accent bg-clip-text text-transparent">DocVision AI</h1>
            </div>
            
            <div class="hidden md:flex items-center space-x-6">
                <a href="#" class="font-medium text-slate-700 hover:text-primary transition-colors">首页</a>
                <a href="#features" class="font-medium text-slate-700 hover:text-primary transition-colors">功能</a>
                <a href="#how-it-works" class="font-medium text-slate-700 hover:text-primary transition-colors">使用方法</a>
            </div>
            
            <div class="flex items-center space-x-3">
                <button id="theme-toggle" class="p-2 rounded-full hover:bg-slate-100 transition-colors">
                    <i class="fa fa-moon-o text-slate-600"></i>
                </button>
                <button class="bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-lg transition-all transform hover:scale-105 shadow-md hover:shadow-lg">
                    <i class="fa fa-github mr-2"></i>GitHub
                </button>
            </div>
        </div>
    </nav>

    <!-- 主内容 -->
    <main class="container mx-auto px-4 pt-24 pb-16">
        <!-- 欢迎区域 -->
        <section class="text-center mb-16">
            <h2 class="text-[clamp(2rem,5vw,3.5rem)] font-bold mb-4 leading-tight text-shadow">
                智能<span class="text-primary">文档识别</span>，
                <span class="text-accent">表格提取</span>一体化
            </h2>
            <p class="text-slate-600 text-lg max-w-3xl mx-auto mb-8">
                告别繁琐的手动录入，DocVision AI 为您提供精准高效的文档识别服务，支持多种语言、格式和表格识别。
            </p>
            <div class="flex flex-wrap justify-center gap-4">
                <button id="upload-file" class="bg-primary hover:bg-primary/90 text-white px-6 py-3 rounded-lg text-lg font-medium transition-all transform hover:scale-105 shadow-lg hover:shadow-xl">
                    <i class="fa fa-upload mr-2"></i>上传文件
                </button>
            </div>
        </section>

        <!-- 主要功能区域 -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 max-w-6xl mx-auto">
            <!-- 左侧：图像预览 -->
            <section class="bg-white rounded-2xl shadow-xl overflow-hidden">
                <div class="p-6 border-b border-slate-100">
                    <h3 class="text-xl font-semibold flex items-center">
                        <i class="fa fa-image text-primary mr-2"></i>图像预览
                    </h3>
                </div>
                
                <div class="p-6">
                    <!-- 图像显示区域 -->
                    <div class="aspect-video bg-slate-100 rounded-xl overflow-hidden relative border-2 border-dashed border-slate-300 hover:border-primary transition-colors cursor-pointer" id="image-container">
                        <img id="captured-image" class="w-full h-full object-contain hidden" alt="已上传的图像">
                        <!-- 叠加：透视角点标注画布（第二步使用） -->
                        <canvas id="perspective-canvas" class="absolute inset-0 hidden"></canvas>
                        
                        <!-- 上传占位符 -->
                        <div id="upload-placeholder" class="absolute inset-0 flex flex-col items-center justify-center">
                            <i class="fa fa-cloud-upload text-6xl text-slate-400 mb-4"></i>
                            <p class="text-slate-500 mb-2">点击或拖拽上传图片</p>
                            <p class="text-sm text-slate-400">支持表格识别和文档提取</p>
                        </div>
                    </div>

                    <!-- 流程步骤指示器（五步） -->
                    <div id="steps-indicator" class="mt-4 flex justify-between items-center mb-4">
                        <div class="flex-1 flex flex-col items-center">
                            <div id="step-1" class="w-8 h-8 rounded-full bg-primary text-white flex items-center justify-center font-medium">1</div>
                            <span class="text-xs mt-1 text-slate-600">上传</span>
                        </div>
                        <div class="flex-1 flex items-center">
                            <div id="step-line-1-2" class="h-1 bg-slate-200 w-full"></div>
                        </div>
                        <div class="flex-1 flex flex-col items-center">
                            <div id="step-2" class="w-8 h-8 rounded-full bg-slate-200 text-slate-600 flex items-center justify-center font-medium">2</div>
                            <span class="text-xs mt-1 text-slate-600">透视</span>
                        </div>
                        <div class="flex-1 flex items-center">
                            <div id="step-line-2-3" class="h-1 bg-slate-200 w-full"></div>
                        </div>
                        <div class="flex-1 flex flex-col items-center">
                            <div id="step-3" class="w-8 h-8 rounded-full bg-slate-200 text-slate-600 flex items-center justify-center font-medium">3</div>
                            <span class="text-xs mt-1 text-slate-600">旋转</span>
                        </div>
                        <div class="flex-1 flex items-center">
                            <div id="step-line-3-4" class="h-1 bg-slate-200 w-full"></div>
                        </div>
                        <div class="flex-1 flex flex-col items-center">
                            <div id="step-4" class="w-8 h-8 rounded-full bg-slate-200 text-slate-600 flex items-center justify-center font-medium">4</div>
                            <span class="text-xs mt-1 text-slate-600">框选</span>
                        </div>
                        <div class="flex-1 flex items-center">
                            <div id="step-line-4-5" class="h-1 bg-slate-200 w-full"></div>
                        </div>
                        <div class="flex-1 flex flex-col items-center">
                            <div id="step-5" class="w-8 h-8 rounded-full bg-slate-200 text-slate-600 flex items-center justify-center font-medium">5</div>
                            <span class="text-xs mt-1 text-slate-600">识别</span>
                        </div>
                    </div>

                <!-- 透视矫正界面（第二步，可选） -->
                <div id="perspective-stage" class="mt-6 hidden">
                    <h4 class="text-center text-slate-600 mb-2">透视矫正（可选）</h4>
                    <p class="text-center text-xs text-slate-500 mb-3">可在图像上依次点击标注四个角点（左上→右上→右下→左下），再执行矫正</p>
                    <div class="flex gap-3">
                        <button id="skip-perspective" class="flex-1 bg-slate-100 hover:bg-slate-200 text-slate-700 py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all">
                            <i class="fa fa-arrow-right mr-2"></i>跳过矫正，进入旋转
                        </button>
                        <button id="apply-perspective" class="flex-1 bg-primary hover:bg-primary/90 text-white py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all">
                            <i class="fa fa-magic mr-2"></i>执行矫正并进入旋转
                        </button>
                        <button id="clear-perspective-points" class="px-4 bg-slate-100 hover:bg-slate-200 text-slate-700 py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all">
                            <i class="fa fa-eraser mr-2"></i>清除角点
                        </button>
                        <button id="back-to-upload" class="px-4 bg-slate-100 hover:bg-slate-200 text-slate-700 py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all">
                            <i class="fa fa-arrow-left mr-2"></i>返回上传
                        </button>
                    </div>
                    <div id="perspective-overlay-container" class="bg-slate-50 rounded-lg border border-slate-200 p-3 mt-4 hidden">
                        <h5 class="text-sm font-medium text-slate-600 mb-2">矫正边界预览</h5>
                        <div class="bg-white rounded-lg overflow-auto border border-slate-200 max-h-[50vh] flex items-center justify-center">
                            <img id="perspective-overlay" class="block" alt="透视矫正边界预览">
                        </div>
                    </div>
                </div>

                <!-- 旋转界面 -->
                <div id="rotate-stage" class="mt-6 hidden space-y-4">
                    <h4 class="text-center text-slate-600">调整图像方向</h4>
                    <div class="flex flex-wrap gap-3 justify-center">
                        <button id="rotate-left" class="bg-slate-100 hover:bg-slate-200 text-slate-700 p-3 rounded-full shadow-sm hover:shadow transition-all">
                            <i class="fa fa-rotate-left text-xl"></i>
                        </button>
                        <button id="rotate-right" class="bg-slate-100 hover:bg-slate-200 text-slate-700 p-3 rounded-full shadow-sm hover:shadow transition-all">
                            <i class="fa fa-rotate-right text-xl"></i>
                        </button>
                        <!-- 已移除增强图像清晰度按钮 -->
                        <button id="retake" class="bg-slate-100 hover:bg-slate-200 text-slate-700 p-3 rounded-full shadow-sm hover:shadow transition-all">
                            <i class="fa fa-refresh text-xl"></i>
                        </button>
                    </div>
                    
                    <!-- 自定义角度旋转控件 -->
                    <div class="px-4 py-2">
                        <div class="flex items-center justify-between mb-1">
                            <label for="rotate-slider" class="text-sm text-slate-600">自定义角度:</label>
                            <div class="flex items-center">
                                <input id="rotate-input" type="number" min="-359" max="359" value="0" class="w-16 px-2 py-1 border border-slate-300 rounded text-center text-sm">
                                <span class="ml-1 text-sm text-slate-600">°</span>
                                <button id="apply-rotation" class="ml-2 px-3 py-1 bg-primary text-white text-sm rounded">应用</button>
                            </div>
                        </div>
                        <input id="rotate-slider" type="range" min="-359" max="359" step="1" value="0" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    
                    <div class="flex gap-3">
                        <button id="back-to-perspective" class="flex-1 bg-slate-100 hover:bg-slate-200 text-slate-700 py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all">
                            <i class="fa fa-arrow-left mr-2"></i>返回透视
                        </button>
                        <button id="next-to-crop" class="flex-1 bg-primary hover:bg-primary/90 text-white py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all">
                            <i class="fa fa-arrow-right mr-2"></i>下一步：框选
                        </button>
                    </div>
                </div>

                <!-- 框选界面 -->
                <div id="crop-stage" class="mt-6 hidden">
                    <h4 class="text-center text-slate-600 mb-4">框选识别区域</h4>
                    
                    <!-- 框选容器 -->
                    <div id="crop-container" class="relative w-full aspect-video bg-slate-50 border border-slate-200 rounded-lg mb-4">
                        <img id="crop-image" class="w-full h-full object-contain" alt="用于框选的图像">
                        <!-- 裁剪框将通过JavaScript动态创建 -->
                    </div>
                    
                    <div class="flex gap-3">
                        <button id="back-to-rotate" class="flex-1 bg-slate-100 hover:bg-slate-200 text-slate-700 py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all">
                            <i class="fa fa-arrow-left mr-2"></i>返回旋转
                        </button>
                        <button id="next-to-recognize" class="flex-1 bg-primary hover:bg-primary/90 text-white py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all">
                            <i class="fa fa-check mr-2"></i>框选全部区域
                        </button>
                    </div>
                </div>

                <!-- 识别界面 -->
                <div id="recognize-stage" class="mt-6 hidden space-y-4">
                    <h4 class="text-center text-slate-600">选择识别方式</h4>
                    
                    <div class="flex gap-3">
                        <button id="back-to-crop" class="flex-1 bg-slate-100 hover:bg-slate-200 text-slate-700 py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all">
                            <i class="fa fa-arrow-left mr-2"></i>返回框选
                        </button>
                    </div>
                    
                    <!-- 自动识别开关（已移除1:1像素预览） -->
                    <div class="flex items-center justify-center gap-4 text-sm text-slate-600">
                        <label class="flex items-center gap-2"><input id="auto-ocr-toggle" type="checkbox" class="w-4 h-4" checked>实时自动识别</label>
                    </div>
                    
                    <!-- 框选区域预览 -->
                    <div id="crop-preview-container" class="bg-slate-50 rounded-lg border border-slate-200 p-3">
                        <h5 class="text-sm font-medium text-slate-600 mb-2">框选区域预览</h5>
                        <div id="crop-preview-frame" class="bg-white rounded-lg overflow-auto border border-slate-200 max-h-[60vh] flex items-center justify-center">
                            <img id="crop-preview" class="block" alt="框选区域预览">
                        </div>
                    </div>
                    
                    <div class="flex gap-3">
                        <button id="start-ocr" class="flex-1 bg-primary hover:bg-primary/90 text-white py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all" title="本地识别">
                            <i class="fa fa-file-text-o mr-2"></i>开始识别
                        </button>
                        <button id="start-ocr-rapid" class="flex-1 bg-primary/70 hover:bg-primary/80 text-white py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all" title="本地识别2（RapidOCR）">
                            <i class="fa fa-bolt mr-2"></i>本地识别2
                        </button>
                        <button id="start-ocr-doubao" class="flex-1 bg-primary/80 hover:bg-primary text-white py-2.5 rounded-lg font-medium shadow-md hover:shadow-lg transition-all" title="豆包云端识别">
                            <i class="fa fa-cloud mr-2"></i>云端识别
                        </button>
                    </div>
                </div>
                </div>
            </section>

            <!-- 右侧：识别结果和编辑 -->
            <section class="bg-white rounded-2xl shadow-xl overflow-hidden">
                <div class="p-6 border-b border-slate-100 flex justify-between items-center">
                    <h3 class="text-xl font-semibold flex items-center">
                        <i class="fa fa-file-text text-accent mr-2"></i>识别结果
                    </h3>
                    <div class="flex gap-2">
                        <button id="copy-text" class="p-2 rounded-lg hover:bg-slate-100 text-slate-600 transition-colors">
                            <i class="fa fa-copy"></i>
                        </button>
                        <button id="fix-text" class="p-2 rounded-lg hover:bg-slate-100 text-slate-600 transition-colors" title="规则纠错">
                            <i class="fa fa-magic"></i>
                        </button>
                        <button id="fix-text-llm" class="p-2 rounded-lg hover:bg-slate-100 text-slate-600 transition-colors" title="LLM纠错">
                            <i class="fa fa-magic"></i><span class="ml-1 text-xs">LLM</span>
                        </button>
                        <button id="llm-extract" class="p-2 rounded-lg hover:bg-slate-100 text-slate-600 transition-colors" title="结构化抽取">
                            <i class="fa fa-object-group"></i>
                        </button>
                        <button id="download-text" class="p-2 rounded-lg hover:bg-slate-100 text-slate-600 transition-colors">
                            <i class="fa fa-file-text-o"></i>
                        </button>
                        <button id="save-as-word" class="p-2 rounded-lg hover:bg-slate-100 text-slate-600 transition-colors">
                            <i class="fa fa-file-word-o"></i>
                        </button>

                    </div>
                </div>
                
                <div class="p-6">
                    <!-- 结果编辑区域 -->
                    <div id="result-placeholder" class="aspect-video flex flex-col items-center justify-center text-slate-400">
                        <i class="fa fa-file-text-o text-6xl mb-4"></i>
                        <p>识别结果将显示在这里</p>
                    </div>
                    
                    <div id="result-container" class="hidden">
                        <div class="space-y-6">
                            <div class="hidden">
                                <div class="mb-2 text-slate-600 font-medium flex items-center justify-between">
                                    <span>原始识别</span>
                                    <div class="flex gap-2">
                                        <button id="download-text-original" class="text-xs px-2 py-1 rounded hover:bg-slate-100 text-slate-600" title="导出TXT"><i class="fa fa-file-text-o"></i></button>
                                        <button id="save-as-word-original" class="text-xs px-2 py-1 rounded hover:bg-slate-100 text-slate-600" title="导出Word"><i class="fa fa-file-word-o"></i></button>
                                    </div>
                                </div>
                                <textarea id="result-text" class="w-full min-h-[420px] p-4 border border-slate-200 rounded-lg focus:ring-2 focus:ring-primary/50 focus:border-primary outline-none transition-all resize-none"></textarea>
                                <div class="mt-2 text-xs text-slate-500"><span id="text-stats">0 字符</span></div>
                            </div>
                            <div>
                                <div class="mb-2 text-slate-600 font-medium flex items-center justify-between">
                                    <span>本地识别</span>
                                    <div class="flex gap-2">
                                        <button id="download-text-enhanced" class="text-xs px-2 py-1 rounded hover:bg-slate-100 text-slate-600" title="导出TXT"><i class="fa fa-file-text-o"></i></button>
                                        <button id="save-as-word-enhanced" class="text-xs px-2 py-1 rounded hover:bg-slate-100 text-slate-600" title="导出Word"><i class="fa fa-file-word-o"></i></button>
                                    </div>
                                </div>
                                <textarea id="result-text-enhanced" class="w-full min-h-[420px] p-4 border border-slate-200 rounded-lg focus:ring-2 focus:ring-primary/50 focus:border-primary outline-none transition-all resize-none"></textarea>
                                <div class="mt-2 text-xs text-slate-500"><span id="text-stats-enhanced">0 字符</span></div>
                            </div>
                            <div>
                                <div class="mb-2 text-slate-600 font-medium flex items-center justify-between">
                                    <span>本地识别2</span>
                                    <div class="flex gap-2">
                                        <button id="download-text-local2" class="text-xs px-2 py-1 rounded hover:bg-slate-100 text-slate-600" title="导出TXT"><i class="fa fa-file-text-o"></i></button>
                                        <button id="save-as-word-local2" class="text-xs px-2 py-1 rounded hover:bg-slate-100 text-slate-600" title="导出Word"><i class="fa fa-file-word-o"></i></button>
                                    </div>
                                </div>
                                <textarea id="result-text-local2" class="w-full min-h-[420px] p-4 border border-slate-200 rounded-lg focus:ring-2 focus:ring-primary/50 focus:border-primary outline-none transition-all resize-none"></textarea>
                                <div class="mt-2 text-xs text-slate-500"><span id="text-stats-local2">0 字符</span></div>
                            </div>
                            <div>
                                <div class="mb-2 text-slate-600 font-medium flex items-center justify-between">
                                    <span>云端识别</span>
                                    <div class="flex gap-2">
                                        <button id="download-text-cloud" class="text-xs px-2 py-1 rounded hover:bg-slate-100 text-slate-600" title="导出TXT"><i class="fa fa-file-text-o"></i></button>
                                        <button id="save-as-word-cloud" class="text-xs px-2 py-1 rounded hover:bg-slate-100 text-slate-600" title="导出Word"><i class="fa fa-file-word-o"></i></button>
                                    </div>
                                </div>
                                <textarea id="result-text-cloud" class="w-full min-h-[420px] p-4 border border-slate-200 rounded-lg focus:ring-2 focus:ring-primary/50 focus:border-primary outline-none transition-all resize-none"></textarea>
                                <div class="mt-2 text-xs text-slate-500"><span id="text-stats-cloud">0 字符</span></div>
                            </div>
                        </div>
                        <div class="mt-4 text-sm text-slate-500 flex justify-between items-center">
                            <span>对比后可复制或保存到文档</span>
                            <div class="flex gap-2">
                                <button class="text-slate-600 hover:text-primary transition-colors px-2 py-1 rounded hover:bg-slate-100">
                                    <i class="fa fa-check mr-1"></i>保存
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </div>

        <!-- 功能介绍 -->
        <section id="features" class="mt-24 max-w-6xl mx-auto">
            <h2 class="text-3xl font-bold text-center mb-16">强大功能</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                <div class="bg-white p-6 rounded-xl shadow-lg hover:shadow-xl transition-all transform hover:-translate-y-1">
                    <div class="w-14 h-14 bg-blue-100 rounded-full flex items-center justify-center mb-4">
                        <i class="fa fa-camera text-2xl text-primary"></i>
                    </div>
                    <h3 class="text-xl font-semibold mb-2">相机实时扫描</h3>
                    <p class="text-slate-600">支持前后摄像头切换，实时预览和拍摄，智能识别各种文档类型。</p>
                </div>
                
                <div class="bg-white p-6 rounded-xl shadow-lg hover:shadow-xl transition-all transform hover:-translate-y-1">
                    <div class="w-14 h-14 bg-blue-100 rounded-full flex items-center justify-center mb-4">
                        <i class="fa fa-file-text text-2xl text-primary"></i>
                    </div>
                    <h3 class="text-xl font-semibold mb-2">多语言OCR</h3>
                    <p class="text-slate-600">支持中英文混合识别，识别准确率高，自动优化文本格式和版面。</p>
                </div>
                
                <div class="bg-white p-6 rounded-xl shadow-lg hover:shadow-xl transition-all transform hover:-translate-y-1">
                    <div class="w-14 h-14 bg-blue-100 rounded-full flex items-center justify-center mb-4">
                        <i class="fa fa-magic text-2xl text-primary"></i>
                    </div>
                    <h3 class="text-xl font-semibold mb-2">智能文本纠错</h3>
                    <p class="text-slate-600">自动识别和纠正常见的OCR错误，提升识别结果的准确性。</p>
                </div>
            </div>
        </section>

        <!-- 使用方法 -->
        <section id="how-it-works" class="mt-24 max-w-6xl mx-auto">
            <h2 class="text-3xl font-bold text-center mb-16">使用步骤</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div class="text-center">
                    <div class="w-16 h-16 bg-primary text-white rounded-full flex items-center justify-center mx-auto mb-4 text-2xl font-bold shadow-lg">1</div>
                    <h3 class="font-semibold mb-2">启动相机</h3>
                    <p class="text-slate-600 text-sm">点击「开始扫描」按钮启动摄像头</p>
                </div>
                
                <div class="text-center">
                    <div class="w-16 h-16 bg-primary text-white rounded-full flex items-center justify-center mx-auto mb-4 text-2xl font-bold shadow-lg">2</div>
                    <h3 class="font-semibold mb-2">拍摄文档</h3>
                    <p class="text-slate-600 text-sm">将文档对准相机，点击拍摄按钮</p>
                </div>
                
                <div class="text-center">
                    <div class="w-16 h-16 bg-primary text-white rounded-full flex items-center justify-center mx-auto mb-4 text-2xl font-bold shadow-lg">3</div>
                    <h3 class="font-semibold mb-2">调整图像</h3>
                    <p class="text-slate-600 text-sm">旋转图像至正确方向，准备识别</p>
                </div>
                
                <div class="text-center">
                    <div class="w-16 h-16 bg-primary text-white rounded-full flex items-center justify-center mx-auto mb-4 text-2xl font-bold shadow-lg">4</div>
                    <h3 class="font-semibold mb-2">开始识别</h3>
                    <p class="text-slate-600 text-sm">点击「开始识别」获取文本内容</p>
                </div>
            </div>
        </section>
    </main>

    <!-- 页脚 -->
    <footer class="bg-dark text-white py-12">
        <div class="container mx-auto px-4">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                <div>
                    <div class="flex items-center space-x-2 mb-4">
                        <i class="fa fa-file-text-o text-2xl text-primary"></i>
                        <h2 class="text-xl font-bold">DocVision AI</h2>
                    </div>
                    <p class="text-slate-400 mb-4">智能文档识别系统，让文档数字化变得简单高效。</p>
                    <div class="flex space-x-4">
                        <a href="#" class="text-slate-400 hover:text-primary transition-colors">
                            <i class="fa fa-github text-xl"></i>
                        </a>
                        <a href="#" class="text-slate-400 hover:text-primary transition-colors">
                            <i class="fa fa-twitter text-xl"></i>
                        </a>
                        <a href="#" class="text-slate-400 hover:text-primary transition-colors">
                            <i class="fa fa-linkedin text-xl"></i>
                        </a>
                    </div>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold mb-4">快速链接</h3>
                    <ul class="space-y-2">
                        <li><a href="#" class="text-slate-400 hover:text-white transition-colors">首页</a></li>
                        <li><a href="#features" class="text-slate-400 hover:text-white transition-colors">功能</a></li>
                        <li><a href="#how-it-works" class="text-slate-400 hover:text-white transition-colors">使用方法</a></li>
                        <li><a href="#" class="text-slate-400 hover:text-white transition-colors">API文档</a></li>
                    </ul>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold mb-4">联系我们</h3>
                    <ul class="space-y-2">
                        <li class="flex items-center text-slate-400">
                            <i class="fa fa-envelope-o mr-2"></i>
                            <span>contact@docvision.ai</span>
                        </li>
                        <li class="flex items-center text-slate-400">
                            <i class="fa fa-github mr-2"></i>
                            <span>github.com/docvision</span>
                        </li>
                    </ul>
                </div>
            </div>
            
            <div class="border-t border-slate-800 mt-8 pt-8 text-center text-slate-500">
                <p>&copy; 2024 DocVision AI. 保留所有权利。</p>
            </div>
        </div>
    </footer>

    <!-- 加载中模态框 -->
    <div id="loading-modal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden backdrop-blur-sm">
        <div class="bg-white p-6 rounded-xl shadow-2xl flex flex-col items-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mb-4"></div>
            <p id="loading-text" class="text-slate-700 font-medium">处理中...</p>
        </div>
    </div>

    <!-- 通知提示 -->
    <div id="toast" class="fixed bottom-4 right-4 bg-slate-800 text-white px-4 py-3 rounded-lg shadow-lg transform translate-y-20 opacity-0 transition-all duration-300 z-50">
        <div class="flex items-center">
            <i id="toast-icon" class="fa fa-check-circle text-green-400 mr-2"></i>
            <span id="toast-message">操作成功</span>
        </div>
    </div>

    <!-- 全局错误捕获 -->
    <script>
       window.addEventListener('error', function(e) {
         const loc = (e.filename || 'inline') + ':' + e.lineno + ':' + e.colno;
         console.log('GlobalError:', e.message, 'at', loc);
         alert('GlobalError: ' + e.message + '\n' + loc);
       });
     </script>

    <!-- 主要JavaScript -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM元素
            const capturedImage = document.getElementById('captured-image');
            const uploadPlaceholder = document.getElementById('upload-placeholder');
            const resultPlaceholder = document.getElementById('result-placeholder');
            const resultContainer = document.getElementById('result-container');
            const resultText = document.getElementById('result-text');
const resultTextEnhanced = document.getElementById('result-text-enhanced');
const resultTextLocal2 = document.getElementById('result-text-local2');
const resultTextCloud = document.getElementById('result-text-cloud');
            const textStats = document.getElementById('text-stats');
const textStatsEnhanced = document.getElementById('text-stats-enhanced');
const textStatsLocal2 = document.getElementById('text-stats-local2');
const textStatsCloud = document.getElementById('text-stats-cloud');
            const loadingModal = document.getElementById('loading-modal');
            const loadingText = document.getElementById('loading-text');
            const toast = document.getElementById('toast');
            const toastIcon = document.getElementById('toast-icon');
            const toastMessage = document.getElementById('toast-message');
            const navbar = document.getElementById('navbar');
            const imageContainer = document.getElementById('image-container');
            
            // 多步骤相关元素
            const rotateStage = document.getElementById('rotate-stage');
            const cropStage = document.getElementById('crop-stage');
            const recognizeStage = document.getElementById('recognize-stage');
            const cropImage = document.getElementById('crop-image');
            const cropContainer = document.getElementById('crop-container');
            const autoOcrToggle = document.getElementById('auto-ocr-toggle');
            if (autoOcrToggle) {
                autoOcrToggle.checked = true;
                autoOcrToggle.addEventListener('change', () => {
                    autoOCREnabled = autoOcrToggle.checked;
                    if (autoOCREnabled) scheduleAutoOCR();
                    try { createCropPreview(); } catch {}
                });
            }
            
            // 步骤指示器元素
            const step1 = document.getElementById('step-1');
            const step2 = document.getElementById('step-2');
            const step3 = document.getElementById('step-3');
            const step4 = document.getElementById('step-4');
            const step5 = document.getElementById('step-5');
            const stepLine12 = document.getElementById('step-line-1-2');
            const stepLine23 = document.getElementById('step-line-2-3');
            const stepLine34 = document.getElementById('step-line-3-4');
            const stepLine45 = document.getElementById('step-line-4-5');

            // 新增：透视界面元素
            const perspectiveStage = document.getElementById('perspective-stage');
            const perspectiveOverlayContainer = document.getElementById('perspective-overlay-container');
            const perspectiveOverlay = document.getElementById('perspective-overlay');

            // 状态变量
            let originalImage = null; // 上传完成的原始图（未透视、未旋转）
            let currentImage = null;
            let currentRotation = 0;
            let currentStep = 0; // 0: 初始状态, 1: 上传完成, 2: 旋转完成, 3: 框选完成
            let cropSelection = { x1: 0, y1: 0, x2: 0, y2: 0, active: false };
            // 防止拖拽后误触发点击上传导致重复弹窗
            let suppressUploadPrompt = false;
            // 防抖与重入控制：阻止连续打开文件选择器
            let uploadDialogOpen = false;
            let lastDropAt = 0;
            // 自动应用预览旋转的回退状态
            let prevImageBeforeAutoApply = null;
            let prevRotationBeforeAutoApply = 0;
            let autoAppliedFromNext = false;

            // 显示通知
            function showToast(message, isSuccess = true) {
                toastMessage.textContent = message;
                toastIcon.className = isSuccess 
                    ? 'fa fa-check-circle text-green-400 mr-2' 
                    : 'fa fa-exclamation-circle text-red-400 mr-2';
                toast.classList.remove('translate-y-20', 'opacity-0');
                toast.classList.add('translate-y-0', 'opacity-100');
                
                setTimeout(() => {
                    toast.classList.remove('translate-y-0', 'opacity-100');
                    toast.classList.add('translate-y-20', 'opacity-0');
                }, 3000);
            }

            // 显示加载状态
            function showLoading(message = '处理中...') {
                loadingText.textContent = message;
                loadingModal.classList.remove('hidden');
            }

            // 隐藏加载状态
            function hideLoading() {
                loadingModal.classList.add('hidden');
            }

            // 更新文本统计（本地/云端）
            function updateTextStats() {
                const t2 = resultTextEnhanced ? (resultTextEnhanced.value || '') : '';
                if (typeof textStatsEnhanced !== 'undefined' && textStatsEnhanced) {
                    textStatsEnhanced.textContent = `${t2.length} 字符`;
                }
                const t4 = (typeof resultTextLocal2 !== 'undefined' && resultTextLocal2) ? (resultTextLocal2.value || '') : '';
                if (typeof textStatsLocal2 !== 'undefined' && textStatsLocal2) {
                    textStatsLocal2.textContent = `${t4.length} 字符`;
                }
                const t3 = (typeof resultTextCloud !== 'undefined' && resultTextCloud) ? (resultTextCloud.value || '') : '';
                if (typeof textStatsCloud !== 'undefined' && textStatsCloud) {
                    textStatsCloud.textContent = `${t3.length} 字符`;
                }
            }

            // 更新步骤指示器（五步）
            function updateStepIndicator(step) {
                // 重置所有步骤
                const steps = [step1, step2, step3, step4, step5];
                for (let i = 0; i < steps.length; i++) {
                    steps[i].className = 'w-8 h-8 rounded-full bg-slate-200 text-slate-600 flex items-center justify-center font-medium';
                }
                const lines = [stepLine12, stepLine23, stepLine34, stepLine45];
                for (let j = 0; j < lines.length; j++) {
                    lines[j].className = 'h-1 bg-slate-200 w-full';
                }
                
                // 设置当前步骤
                if (step >= 1) {
                    step1.className = 'w-8 h-8 rounded-full bg-primary text-white flex items-center justify-center font-medium';
                }
                if (step >= 2) {
                    step2.className = 'w-8 h-8 rounded-full bg-primary text-white flex items-center justify-center font-medium';
                    stepLine12.className = 'h-1 bg-primary w-full';
                }
                if (step >= 3) {
                    step3.className = 'w-8 h-8 rounded-full bg-primary text-white flex items-center justify-center font-medium';
                    stepLine23.className = 'h-1 bg-primary w-full';
                }
                if (step >= 4) {
                    step4.className = 'w-8 h-8 rounded-full bg-primary text-white flex items-center justify-center font-medium';
                    stepLine34.className = 'h-1 bg-primary w-full';
                }
                if (step >= 5) {
                    step5.className = 'w-8 h-8 rounded-full bg-primary text-white flex items-center justify-center font-medium';
                    stepLine45.className = 'h-1 bg-primary w-full';
                }
            }

            // 新增：进入透视界面
            function enterPerspectiveStage() {
                updateStepIndicator(2);
                perspectiveStage.classList.remove('hidden');
                rotateStage.classList.add('hidden');
                cropStage.classList.add('hidden');
                recognizeStage.classList.add('hidden');
                // 进入透视时，强制恢复为上传原图（未旋转、未透视）
                if (originalImage) {
                    currentImage = originalImage;
                    capturedImage.src = originalImage;
                    currentRotation = 0;
                    capturedImage.style.transform = 'none';
                }
                // 隐藏矫正叠加预览，避免误导
                if (perspectiveOverlayContainer) perspectiveOverlayContainer.classList.add('hidden');
                if (perspectiveOverlay) perspectiveOverlay.src = '';
                currentStep = 1;
                try {
                    // 初始化角点数组
                    window.perspectivePoints = [];
                    // 显示并适配画布尺寸
                    const container = document.getElementById('image-container');
                    const imgEl = document.getElementById('captured-image');
                    const canvas = document.getElementById('perspective-canvas');
                    if (container && imgEl && canvas) {
                        canvas.classList.remove('hidden');
                        const rect = container.getBoundingClientRect();
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                        // 绘制工具
                        const ctx = canvas.getContext('2d');
                        const draw = () => {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            // 画已选角点与连线（容器坐标）
                            ctx.fillStyle = '#10b981';
                            ctx.strokeStyle = '#10b981';
                            ctx.lineWidth = 2;
                            for (let i = 0; i < (window.perspectivePoints || []).length; i++) {
                                const p = window.perspectivePoints[i];
                                // 将图像坐标映射到容器坐标
                                const { x: cx, y: cy } = imageToContainer(p.x, p.y, imgEl, container);
                                ctx.beginPath();
                                ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                                ctx.fill();
                                // 连线
                                if (i > 0) {
                                    const p0 = window.perspectivePoints[i - 1];
                                    const c0 = imageToContainer(p0.x, p0.y, imgEl, container);
                                    ctx.beginPath();
                                    ctx.moveTo(c0.x, c0.y);
                                    ctx.lineTo(cx, cy);
                                    ctx.stroke();
                                }
                            }
                            // 闭合四边形
                            if ((window.perspectivePoints || []).length === 4) {
                                const p0 = window.perspectivePoints[0];
                                const c0 = imageToContainer(p0.x, p0.y, imgEl, container);
                                const p3 = window.perspectivePoints[3];
                                const c3 = imageToContainer(p3.x, p3.y, imgEl, container);
                                ctx.beginPath();
                                ctx.moveTo(c3.x, c3.y);
                                ctx.lineTo(c0.x, c0.y);
                                ctx.stroke();
                            }
                        };
                        // 坐标转换：图像坐标 -> 容器坐标
                        const imageToContainer = (ix, iy, img, cont) => {
                            const cRect = cont.getBoundingClientRect();
                            const cw = cRect.width, ch = cRect.height;
                            const nw = img.naturalWidth, nh = img.naturalHeight;
                            if (!nw || !nh) return { x: ix, y: iy };
                            const scale = Math.min(cw / nw, ch / nh);
                            const dw = nw * scale, dh = nh * scale;
                            const ox = (cw - dw) / 2, oy = (ch - dh) / 2;
                            return { x: ox + ix * scale, y: oy + iy * scale };
                        };
                        // 容器坐标 -> 图像坐标
                        const containerToImage = (cx, cy, img, cont) => {
                            const cRect = cont.getBoundingClientRect();
                            const cw = cRect.width, ch = cRect.height;
                            const nw = img.naturalWidth, nh = img.naturalHeight;
                            if (!nw || !nh) return { x: cx, y: cy };
                            const scale = Math.min(cw / nw, ch / nh);
                            const dw = nw * scale, dh = nh * scale;
                            const ox = (cw - dw) / 2, oy = (ch - dh) / 2;
                            return { x: (cx - ox) / scale, y: (cy - oy) / scale };
                        };
                        // 点击添加角点（最多四个）
                        const onClick = (ev) => {
                            const cRect = canvas.getBoundingClientRect();
                            const cx = ev.clientX - cRect.left;
                            const cy = ev.clientY - cRect.top;
                            const { x, y } = containerToImage(cx, cy, imgEl, container);
                            if (!window.perspectivePoints) window.perspectivePoints = [];
                            if (window.perspectivePoints.length < 4) {
                                window.perspectivePoints.push({ x, y });
                            } else {
                                // 达到四个后，从头开始替换
                                window.perspectivePoints = [{ x, y }];
                            }
                            draw();
                        };
                        // 绑定一次
                        if (!canvas.__bound) {
                            canvas.addEventListener('click', onClick);
                            canvas.__bound = true;
                        }
                        // 清除角点按钮
                        const clearBtn = document.getElementById('clear-perspective-points');
                        if (clearBtn && !clearBtn.__bound) {
                            clearBtn.addEventListener('click', () => { window.perspectivePoints = []; draw(); });
                            clearBtn.__bound = true;
                        }
                        // 初次绘制
                        draw();
                    }
                } catch (e) {
                    console.warn('初始化透视画布失败:', e);
                }
            }

            // 新增：执行透视矫正并进入旋转
            async function applyPerspective() {
                if (!currentImage) { showToast('请先上传图片', false); return; }
                showLoading('透视矫正中...');
                try {
                    const API_BASE = window.__API_BASE || `${location.protocol}//${location.hostname}:5000`;
                    const points = (window.perspectivePoints && window.perspectivePoints.length === 4) ? window.perspectivePoints.map(p => ({ x: Number(p.x), y: Number(p.y) })) : undefined;
                    const payload = { image: currentImage.split(',')[1] };
                    if (points) payload.points = points.map(p => [p.x, p.y]);
                    const response = await fetch(`${API_BASE}/api/perspective`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json();
                    if (data.success && data.image) {
                        currentImage = data.image;
                        currentRotation = 0;
                        capturedImage.src = currentImage;
                        capturedImage.style.transform = 'none';
                        // 显示边界叠加预览（如果返回）
                        if (data.overlay && perspectiveOverlay) {
                            perspectiveOverlay.src = data.overlay;
                            if (perspectiveOverlayContainer) perspectiveOverlayContainer.classList.remove('hidden');
                        }
                        showToast(points ? '按手动角点矫正成功，进入旋转' : '矫正成功，进入旋转');
                    } else {
                        showToast('透视矫正失败，已跳过', false);
                    }
                } catch (e) {
                    console.error('透视矫正错误:', e);
                    showToast('透视矫正异常，已跳过', false);
                } finally {
                    hideLoading();
                    enterRotateStage();
                }
            }

            // 进入旋转界面
            function enterRotateStage() {
                updateStepIndicator(3);
                // 隐藏透视画布
                const canvas = document.getElementById('perspective-canvas');
                if (canvas) canvas.classList.add('hidden');
                perspectiveStage.classList.add('hidden');
                rotateStage.classList.remove('hidden');
                cropStage.classList.add('hidden');
                recognizeStage.classList.add('hidden');
                currentStep = 2;
            }

            // 返回到上传步骤
            function enterUploadStep() {
                updateStepIndicator(1);
                document.getElementById('perspective-stage')?.classList.add('hidden');
                document.getElementById('rotate-stage')?.classList.add('hidden');
                document.getElementById('crop-stage')?.classList.add('hidden');
                document.getElementById('recognize-stage')?.classList.add('hidden');
                document.getElementById('upload-placeholder')?.classList.remove('hidden');
                document.getElementById('captured-image')?.classList.add('hidden');
                document.getElementById('perspective-canvas')?.classList.add('hidden');
                if (typeof showToast === 'function') showToast('已返回上传步骤');
            }

            // 进入框选界面（自动应用未提交的预览旋转）
            async function enterCropStage() {
                // 若存在未应用的预览旋转（CSS），在切入框选前自动应用到实际图像
                try {
                    const transform = (capturedImage && capturedImage.style && capturedImage.style.transform) || '';
                    let previewAngle = currentRotation;
                    const match = transform.match(/rotate\(([-\d.]+)deg\)/);
                    if (match) {
                        previewAngle = parseFloat(match[1]) || 0;
                    }
                    let delta = previewAngle - currentRotation;
                    // 规范化到[-360, 360]
                    if (!isNaN(delta)) {
                        delta = ((delta % 360) + 360) % 360; // 转为[0,360)
                        if (delta > 180) delta -= 360;       // 映射到[-180,180]
                    }
                    if (Math.abs(delta) > 0.1) {
                         console.log('检测到未应用的预览旋转，自动应用:', delta);
                         // 保存回退状态，便于从第三步返回第二步时恢复原图
                         prevImageBeforeAutoApply = currentImage;
                         prevRotationBeforeAutoApply = currentRotation;
                         autoAppliedFromNext = true;
                         await applyRotation(delta);
                         // 应用后重置控件数值
                         const rotateSlider = document.getElementById('rotate-slider');
                         const rotateInput = document.getElementById('rotate-input');
                         if (rotateSlider) rotateSlider.value = 0;
                         if (rotateInput) rotateInput.value = 0;
                     }
                } catch (e) {
                    console.warn('自动应用预览旋转失败，继续进入框选:', e);
                }

                // 合并第四、第五步：进入裁剪界面时同时展示识别界面
            updateStepIndicator(5);
                rotateStage.classList.add('hidden');
                cropStage.classList.remove('hidden');
                recognizeStage.classList.remove('hidden');
                
                // 设置裁剪图像（此时已应用旋转，确保为最新图像）
                cropImage.src = currentImage;
                
                // 重置裁剪选择
                cropSelection = { x1: 0, y1: 0, x2: 0, y2: 0, active: false };
                
                // 初始化框选功能
                initCropSelection();
                
                // 初次创建预览
                try { createCropPreview(); } catch (e) { console.warn('初次预览失败:', e); }
                
                currentStep = 2;
            }

            // 全新实现的图片裁剪预览函数（按框选区域裁剪生成预览）
            function createCropPreview() {
                try {
                    const cropPreviewContainer = document.getElementById('crop-preview-container');
                    const previewImg = document.getElementById('crop-preview');

                    if (!previewImg || !cropPreviewContainer || !currentImage) return;

                    // 使用已计算的原始图像坐标；若不存在则尝试根据保存的DOM坐标计算
                    const area = savedImageCoordinates || (savedCropSelection ? calculateImageCoordinates(savedCropSelection) : null);

                    const img = new Image();
                    img.onload = () => {
                        // 默认使用整图，若提供有效坐标则进行裁剪
                        let x1 = 0, y1 = 0, x2 = img.naturalWidth, y2 = img.naturalHeight;
                        if (area && Number.isFinite(area.x1) && Number.isFinite(area.y1) && Number.isFinite(area.x2) && Number.isFinite(area.y2)) {
                            // 起点向下取整、终点向上取整，预览与实际裁剪一致覆盖边界像素
                            x1 = Math.max(0, Math.min(img.naturalWidth, Math.floor(area.x1)));
                            y1 = Math.max(0, Math.min(img.naturalHeight, Math.floor(area.y1)));
                            x2 = Math.max(0, Math.min(img.naturalWidth, Math.ceil(area.x2)));
                            y2 = Math.max(0, Math.min(img.naturalHeight, Math.ceil(area.y2)));
                            if (x2 <= x1 || y2 <= y1) {
                                // 坐标无效时回退到整图
                                x1 = 0; y1 = 0; x2 = img.naturalWidth; y2 = img.naturalHeight;
                            }
                        }
                        const sw = x2 - x1;
                        const sh = y2 - y1;

                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        // 关闭平滑避免半像素插值导致边缘发虚
                        ctx.imageSmoothingEnabled = false;
                        // 自适应预览：画布为选区尺寸
                        canvas.width = sw;
                        canvas.height = sh;
                        ctx.drawImage(img, x1, y1, sw, sh, 0, 0, sw, sh);

                        previewImg.src = canvas.toDataURL('image/png');
                        previewImg.alt = '框选区域预览';
                        // 自适应：宽度撑满容器，高度自适应；保持完整显示
                        previewImg.style.width = '100%';
                        previewImg.style.height = 'auto';
                        previewImg.style.maxWidth = '100%';
                        previewImg.style.maxHeight = '60vh';
                        previewImg.style.imageRendering = 'auto';
                        cropPreviewContainer.style.display = 'block';
                    };
                    img.onerror = (err) => {
                        console.error('加载原图用于预览失败:', err);
                        // 回退：仍显示整图
                        previewImg.src = currentImage;
                        previewImg.style.width = '100%';
                        previewImg.style.height = 'auto';
                        previewImg.style.imageRendering = 'auto';
                        cropPreviewContainer.style.display = 'block';
                    };
                    img.src = currentImage;
                } catch (e) {
                    console.error('初始化裁剪预览失败:', e);
                }
            }

            // 识别界面已与裁剪界面合并，保留预览与坐标兜底逻辑
            function enterRecognizeStage() {
                updateStepIndicator(5);
                rotateStage.classList.add('hidden');
                cropStage.classList.remove('hidden');
                recognizeStage.classList.remove('hidden');
                currentStep = 3;
                
                // 创建并显示框选区域预览（优先使用已保存的坐标）
                createCropPreview();
                
                // 不再在识别界面重新计算坐标，避免容器隐藏导致的1x1尺寸误差
                if (savedImageCoordinates) {
                    console.log('进入识别界面，沿用已保存的图像坐标:', savedImageCoordinates);
                } else if (savedCropSelection) {
                    // 若尚未计算，则在进入识别界面前（容器可见时）应已计算；此处仅兜底
                    try {
                        savedImageCoordinates = calculateImageCoordinates(savedCropSelection);
                        console.log('识别界面兜底计算图像坐标:', savedImageCoordinates);
                    } catch (e) {
                        console.warn('识别界面兜底计算坐标失败，后续将按整图处理');
                    }
                }
            }

            // 初始化框选功能
            function initCropSelection() {
                if (!cropContainer || !cropImage) return;
                
                let selectionBox = null;
                
                // 防止浏览器默认的图片拖拽行为
                cropImage.addEventListener('dragstart', function(e) {
                    e.preventDefault();
                });
                
                // 添加阻止拖拽的样式
                cropImage.style.userDrag = 'none';
                cropImage.style.webkitUserDrag = 'none';
                cropImage.style.cursor = 'crosshair';
                
                // 清理之前的事件监听器
                cropContainer.removeEventListener('mousedown', onMouseDown);
                cropContainer.removeEventListener('mousemove', onMouseMove);
                cropContainer.removeEventListener('mouseup', onMouseUp);
                cropContainer.removeEventListener('dragstart', preventDefault);
                
                // 阻止容器的拖拽默认行为
                function preventDefault(e) {
                    e.preventDefault();
                }
                
                cropContainer.addEventListener('dragstart', preventDefault);
                
                function onMouseDown(e) {
                    // 确保点击的是容器而不是其他元素
                    if (e.target === cropImage || e.target === cropContainer) {
                        const rect = cropContainer.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        cropSelection = { x1: x, y1: y, x2: x, y2: y, active: true };
                        
                        // 创建选择框
                        if (!selectionBox) {
                            selectionBox = document.createElement('div');
                            // 使用outline代替border，避免宽高因边框被缩小导致坐标偏差
                            selectionBox.className = 'absolute outline outline-2 outline-dashed outline-primary bg-primary/20';
                            // 使用content-box，width/height不包含outline，确保视觉与坐标一致
                            selectionBox.style.boxSizing = 'content-box';
                            cropContainer.appendChild(selectionBox);
                            // 记录选框DOM引用，确保之后坐标计算与视觉一致
                            cropSelectionBoxEl = selectionBox;
                        }
                        selectionBox.style.display = 'block';
                        updateSelectionBox();
                    }
                }
                
                function onMouseMove(e) {
                    if (!cropSelection.active) return;
                    
                    const rect = cropContainer.getBoundingClientRect();
                    cropSelection.x2 = e.clientX - rect.left;
                    cropSelection.y2 = e.clientY - rect.top;
                    updateSelectionBox();
                    
                    // 实时更新预览与自动识别（节流）
                    const w = Math.abs(cropSelection.x2 - cropSelection.x1);
                    const h = Math.abs(cropSelection.y2 - cropSelection.y1);
                    if (w >= 20 && h >= 20) {
                        savedCropSelection = { ...cropSelection };
                        try { savedImageCoordinates = calculateImageCoordinates(savedCropSelection); } catch (e) {}
                        try { createCropPreview(); } catch (e) {}
                        scheduleAutoOCR();
                    }
                }
                
                function onMouseUp() {
                    cropSelection.active = false;
                    
                    // 确保选择框有最小尺寸
                    if (Math.abs(cropSelection.x2 - cropSelection.x1) < 10 || 
                        Math.abs(cropSelection.y2 - cropSelection.y1) < 10) {
                        console.log('点击操作，未形成有效选择区域');
                        return;
                    }
                    
                    // 保存框选区域到全局变量
                    savedCropSelection = { ...cropSelection };
                    console.log('框选区域已保存:', savedCropSelection);
                    
                    // 立即计算并保存图像坐标（使用新的计算方法）
                    savedImageCoordinates = calculateImageCoordinates(savedCropSelection);
                    console.log('立即计算并保存的图像坐标:', savedImageCoordinates);
                    
                    updateSelectionBox();
                    // 同步更新预览并触发自动识别
                    try { createCropPreview(); } catch (e) {}
                    scheduleAutoOCR();
                }
                
                function updateSelectionBox() {
                    if (!selectionBox) return;
                    
                    // 计算图像内容在容器内的显示区域（object-contain），避免用<img>元素尺寸导致比例不一致
                    const contRect = cropContainer.getBoundingClientRect();
                    const contW = contRect.width || 1;
                    const contH = contRect.height || 1;
                    const natW = cropImage.naturalWidth || 1;
                    const natH = cropImage.naturalHeight || 1;
                    const scale = Math.min(contW / natW, contH / natH);
                    const contentW = Math.max(1, natW * scale);
                    const contentH = Math.max(1, natH * scale);
                    const offsetX = (contW - contentW) / 2;
                    const offsetY = (contH - contentH) / 2;
                    
                    // 将选区限制在图像内容显示区域内，避免超出导致识别区域被夹小
                    let sx1 = Math.min(cropSelection.x1, cropSelection.x2);
                    let sy1 = Math.min(cropSelection.y1, cropSelection.y2);
                    let sx2 = Math.max(cropSelection.x1, cropSelection.x2);
                    let sy2 = Math.max(cropSelection.y1, cropSelection.y2);
                    sx1 = Math.max(offsetX, Math.min(offsetX + contentW, sx1));
                    sy1 = Math.max(offsetY, Math.min(offsetY + contentH, sy1));
                    sx2 = Math.max(offsetX, Math.min(offsetX + contentW, sx2));
                    sy2 = Math.max(offsetY, Math.min(offsetY + contentH, sy2));
                    
                    // 像素对齐：映射到原图像素并反投影回CSS像素，避免高DPI/缩放下的半像素误差
                    const relX1 = Math.max(0, sx1 - offsetX);
                    const relY1 = Math.max(0, sy1 - offsetY);
                    const relX2 = Math.max(0, sx2 - offsetX);
                    const relY2 = Math.max(0, sy2 - offsetY);
                    const ox1 = Math.floor(relX1 / scale);
                    const oy1 = Math.floor(relY1 / scale);
                    const ox2 = Math.ceil(relX2 / scale);
                    const oy2 = Math.ceil(relY2 / scale);
                    const px1 = offsetX + (ox1 * scale);
                    const py1 = offsetY + (oy1 * scale);
                    const px2 = offsetX + (ox2 * scale);
                    const py2 = offsetY + (oy2 * scale);
                    
                    // 将像素对齐后的值写回，确保坐标计算与视觉一致
                    cropSelection.x1 = px1;
                    cropSelection.y1 = py1;
                    cropSelection.x2 = px2;
                    cropSelection.y2 = py2;
                    
                    const width = Math.max(0, px2 - px1);
                    const height = Math.max(0, py2 - py1);
                    
                    selectionBox.style.left = `${px1}px`;
                    selectionBox.style.top = `${py1}px`;
                    selectionBox.style.width = `${width}px`;
                    selectionBox.style.height = `${height}px`;
                }
                
                // 绑定事件监听器
                cropContainer.addEventListener('mousedown', onMouseDown);
                cropContainer.addEventListener('mousemove', onMouseMove);
                cropContainer.addEventListener('mouseup', onMouseUp);
            }

            // 处理文件上传
            function handleFileUpload(file) {
                if (!file) return;
                
                // 检查文件类型
                if (!file.type.match('image.*')) {
                    showToast('请上传图片文件', false);
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    currentImage = event.target.result;
                    originalImage = currentImage; // 保存上传原始图基线
                    currentRotation = 0;
                    
                    uploadPlaceholder.classList.add('hidden');
                    capturedImage.src = currentImage;
                    capturedImage.classList.remove('hidden');
                    suppressUploadPrompt = false;
                    
                    // 隐藏主操作按钮
                    const mainActions = document.getElementById('main-actions');
                    if (mainActions) {
                        mainActions.classList.add('hidden');
                    }
                    
                    // 进入透视界面（新增第二步）
                    enterPerspectiveStage();
                    
                    showToast('文件上传成功，请选择是否进行透视矫正');
                };
                reader.readAsDataURL(file);
            }

            // 触发文件选择器
            function triggerFileUpload() {
                // 在拖拽上传流程中抑制可能的合成点击，避免重复打开
                if (typeof suppressUploadPrompt !== 'undefined' && suppressUploadPrompt) {
                    console.debug('已抑制拖拽后的点击上传以避免重复弹窗');
                    return;
                }
                // 防抖与重入：避免在短时间内或已打开情况下重复打开
                const now = Date.now();
                if (uploadDialogOpen || (now - lastDropAt) < 600) {
                    console.debug('文件选择器已打开或刚刚完成拖拽，已阻止重复弹窗');
                    return;
                }
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = function(e) {
                    uploadDialogOpen = false;
                    handleFileUpload(e.target.files[0]);
                };
                uploadDialogOpen = true;
                // 兜底：若浏览器未触发change或blur，避免卡住
                setTimeout(() => { uploadDialogOpen = false; }, 2000);
                input.click();
            }

            // 实时预览旋转（前端CSS实现）
            function previewRotate(angle) {
                if (!capturedImage) return;
                // 使用 requestAnimationFrame 提升连续滑动时的渲染流畅度
                window.requestAnimationFrame(() => {
                    capturedImage.style.transform = `rotate(${angle}deg)`;
                });
            }
            
            // 应用旋转（后端处理实际旋转）
            async function applyRotation(angle) {
                if (!currentImage) return;
                
                showLoading('旋转中...');
                
                try {
                    // 统一旋转方向：CSS预览的正角为顺时针；OpenCV一般角度正角为逆时针
                    // 对非90度倍数的角度取反，保持与预览一致
                    const near90 = Math.abs(Math.round(angle / 90) * 90 - angle) < 0.1;
                    const sendAngle = near90 ? angle : -angle;
                    console.log('应用旋转角度(发送到后端):', sendAngle, '预览角度:', angle);

                    const API_BASE = window.__API_BASE || `${location.protocol}//${location.hostname}:5000`;
const response = await fetch(`${API_BASE}/api/rotate`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            image: currentImage.split(',')[1],
                            angle: sendAngle
                        })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        currentImage = data.image;
                        capturedImage.src = currentImage;
                        // 同步更新裁剪阶段图像，确保第三步看到的是旋转后的图
                        const cropImgEl = document.getElementById('crop-image');
                        if (cropImgEl) {
                            cropImgEl.src = currentImage;
                            console.log('裁剪阶段图像已同步更新(旋转后):', cropImgEl.src.substring(0, 60) + '...');
                        }
                        // 移除CSS旋转效果
                        capturedImage.style.transform = 'none';
                        
                        // 更新当前旋转角度
                        currentRotation = (currentRotation + angle) % 360;
                        
                        // 旋转后清空旧的框选和坐标，避免错位
                        savedCropSelection = null;
                        savedImageCoordinates = null;
                        
                        hideLoading();
                        showToast('旋转成功，请重新框选区域');
                    } else {
                        throw new Error(data.error || '旋转失败');
                    }
                } catch (error) {
                    console.error('旋转错误:', error);
                    hideLoading();
                    showToast('图像旋转失败', false);
                    // 恢复CSS旋转
                    capturedImage.style.transform = `rotate(${currentRotation}deg)`;
                }
            }
            
            // 快捷旋转（90度）
            async function quickRotate(angle) {
                // 先更新CSS预览
                capturedImage.style.transform = `rotate(${currentRotation + angle}deg)`;
                
                // 然后应用实际旋转
                await applyRotation(angle);
                
                // 同步更新下方旋转角度控件为累计角度（例如：±90、±180）
                const rotateSlider = document.getElementById('rotate-slider');
                const rotateInput = document.getElementById('rotate-input');
                if (rotateSlider) rotateSlider.value = currentRotation;
                if (rotateInput) rotateInput.value = currentRotation;
                console.log('快捷旋转完成，角度控件已更新为累计角度:', currentRotation);
            }
            
            // 已彻底移除图像增强功能

            // 保存框选区域（DOM坐标）
            let savedCropSelection = null;
            // 保存转换后的图像坐标
            let savedImageCoordinates = null;
            // 选框DOM引用（用于精确读取渲染后的选框位置与尺寸）
            let cropSelectionBoxEl = null;
            // 调试：用于显示反投影的红色调试框
            let cropDebugBoxEl = null;
            const DEBUG_CROP = true;
            
            // 自动识别（合并裁剪与识别）
            let autoOCREnabled = true;
            let autoOCRTimer = null;
            const AUTO_OCR_DEBOUNCE_MS = 600;
            function scheduleAutoOCR() {
                if (!autoOCREnabled) return;
                if (autoOCRTimer) clearTimeout(autoOCRTimer);
                autoOCRTimer = setTimeout(() => {
                    performOCR(true).catch(() => {});
                }, AUTO_OCR_DEBOUNCE_MS);
            }
            
            // 修复版图像坐标计算函数
function calculateImageCoordinates(cropArea) {
                try {
                    // 参数验证
                    if (!cropArea || !cropContainer || !currentImage) {
                        console.error('缺少必要参数:', {cropArea, cropContainer, currentImage});
                        return null;
                    }
                    
                    const cropImage = document.getElementById('crop-image');
                    if (!cropImage) {
                        console.error('找不到crop-image元素');
                        return null;
                    }
                    
                    // 规范化框选坐标（初值取鼠标坐标）
                    let x1 = Math.min(Number(cropArea.x1) || 0, Number(cropArea.x2) || 0);
                    let y1 = Math.min(Number(cropArea.y1) || 0, Number(cropArea.y2) || 0);
                    let x2 = Math.max(Number(cropArea.x1) || 0, Number(cropArea.x2) || 0);
                    let y2 = Math.max(Number(cropArea.y1) || 0, Number(cropArea.y2) || 0);
                    
                    // 若有选框DOM，优先使用渲染后的实际位置与尺寸，确保与视觉完全一致
                    if (cropSelectionBoxEl && cropContainer) {
                        const boxRect = cropSelectionBoxEl.getBoundingClientRect();
                        const contRect = cropContainer.getBoundingClientRect();
                        const bx = boxRect.left - contRect.left;
                        const by = boxRect.top - contRect.top;
                        const bw = boxRect.width;
                        const bh = boxRect.height;
                        // 已改用outline，不再扣除边框厚度，直接使用渲染盒尺寸
                        x1 = bx;
                        y1 = by;
                        x2 = bx + bw;
                        y2 = by + bh;
                    }
                    
                    // 确保坐标有效
                    if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {
                        console.error('无效的坐标值:', x1, y1, x2, y2);
                        return null;
                    }
                    
                    // 计算object-contain下的图像内容显示区域与统一缩放比例
                    const containerRect = cropContainer.getBoundingClientRect();
                    const contW = containerRect.width || 1;
                    const contH = containerRect.height || 1;
                    const imgWidth = cropImage.naturalWidth || 1;
                    const imgHeight = cropImage.naturalHeight || 1;
                    const scale = Math.min(contW / imgWidth, contH / imgHeight);
                    const displayWidth = Math.max(1, Math.round(imgWidth * scale));
                    const displayHeight = Math.max(1, Math.round(imgHeight * scale));
                    const imgX = Math.round((contW - displayWidth) / 2);
                    const imgY = Math.round((contH - displayHeight) / 2);
                    
                    console.log('图像内容在容器内位置:', imgX, imgY);
                    console.log('图像显示尺寸(内容):', displayWidth, 'x', displayHeight);
                    console.log('图像原始尺寸:', imgWidth, 'x', imgHeight);
                    console.log('统一缩放比例:', scale);
                    console.log('框选DOM坐标:', x1, y1, x2, y2);
                    
                    // 计算相对于图像内容的坐标（考虑居中偏移）
                    const relativeX1 = Math.max(0, Math.min(displayWidth, x1 - imgX));
                    const relativeY1 = Math.max(0, Math.min(displayHeight, y1 - imgY));
                    const relativeX2 = Math.max(0, Math.min(displayWidth, x2 - imgX));
                    const relativeY2 = Math.max(0, Math.min(displayHeight, y2 - imgY));
                    
                    console.log('相对于图像内容的坐标:', relativeX1, relativeY1, relativeX2, relativeY2);
                    
                    // 转换到原始图像像素坐标（统一比例）
                    // 使用起点向下取整、终点向上取整，避免边界被截断
                    let originalX1 = Math.floor(relativeX1 / scale);
                    let originalY1 = Math.floor(relativeY1 / scale);
                    let originalX2 = Math.ceil(relativeX2 / scale);
                    let originalY2 = Math.ceil(relativeY2 / scale);
                
                // 边界检查
                let safeX1 = Math.max(0, originalX1);
                let safeY1 = Math.max(0, originalY1);
                let safeX2 = Math.min(imgWidth, originalX2);
                let safeY2 = Math.min(imgHeight, originalY2);
                
                // 旋转坐标调整移除：在进入框选前已对图像进行物理旋转，
                // 此处无需再根据 currentRotation 做二次坐标映射，避免错位与边缘像素丢失。
                
                // 最终边界检查
                safeX1 = Math.max(0, safeX1);
                safeY1 = Math.max(0, safeY1);
                safeX2 = Math.min(imgWidth, safeX2);
                safeY2 = Math.min(imgHeight, safeY2);
                
                // 确保x1 <= x2且y1 <= y2
                if (safeX1 > safeX2) { [safeX1, safeX2] = [safeX2, safeX1]; }
                if (safeY1 > safeY2) { [safeY1, safeY2] = [safeY2, safeY1]; }
                
                // 创建转换后的区域对象
                const convertedArea = {
                    x1: safeX1,
                    y1: safeY1,
                    x2: safeX2,
                    y2: safeY2,
                    active: Boolean(cropArea.active) || false
                };
                
                console.log('计算后的图像坐标:', convertedArea.x1, convertedArea.y1, convertedArea.x2, convertedArea.y2);
                
                // 调试：反投影到DOM，显示一个红色对比框，验证选框映射是否一致
                if (DEBUG_CROP && cropContainer) {
                    if (!cropDebugBoxEl) {
                        cropDebugBoxEl = document.createElement('div');
                        cropDebugBoxEl.className = 'absolute pointer-events-none';
                        cropDebugBoxEl.style.border = '1px solid red';
                        cropDebugBoxEl.style.boxSizing = 'border-box';
                        cropDebugBoxEl.style.zIndex = '50';
                        cropContainer.appendChild(cropDebugBoxEl);
                    }
                    const dbgX1 = imgX + (convertedArea.x1 * scale);
                    const dbgY1 = imgY + (convertedArea.y1 * scale);
                    const dbgX2 = imgX + (convertedArea.x2 * scale);
                    const dbgY2 = imgY + (convertedArea.y2 * scale);
                    cropDebugBoxEl.style.left = `${dbgX1}px`;
                    cropDebugBoxEl.style.top = `${dbgY1}px`;
                    cropDebugBoxEl.style.width = `${Math.max(0, dbgX2 - dbgX1)}px`;
                    cropDebugBoxEl.style.height = `${Math.max(0, dbgY2 - dbgY1)}px`;
                }
                
                // 保存结果
                savedImageCoordinates = convertedArea;
                return convertedArea;
            } catch (error) {
                console.error('计算图像坐标时出错:', error);
                return null;
            }
            }

            // 生成裁剪后的图片（直接在前端裁剪并发送）
            async function getCroppedImageBase64(base64Image, area) {
                return new Promise((resolve, reject) => {
                    try {
                        const img = new Image();
                        img.onload = () => {
                            const x1 = Math.max(0, Math.min(img.naturalWidth, Math.floor(area.x1)));
                            const y1 = Math.max(0, Math.min(img.naturalHeight, Math.floor(area.y1)));
                            const x2 = Math.max(0, Math.min(img.naturalWidth, Math.ceil(area.x2)));
                            const y2 = Math.max(0, Math.min(img.naturalHeight, Math.ceil(area.y2)));
                            const w = Math.max(1, x2 - x1);
                            const h = Math.max(1, y2 - y1);
                            const canvas = document.createElement('canvas');
                            canvas.width = w;
                            canvas.height = h;
                            const ctx = canvas.getContext('2d');
                            // 关闭平滑避免半像素插值导致边缘发虚
                            ctx.imageSmoothingEnabled = false;
                            ctx.drawImage(img, x1, y1, w, h, 0, 0, w, h);
                            resolve(canvas.toDataURL('image/png'));
                        };
                        img.onerror = (e) => reject(e);
                        img.src = base64Image;
                    } catch (e) {
                        reject(e);
                    }
                });
            }

            // 执行OCR
            async function performOCR(quiet = false, variant = null) {
                if (!currentImage) return;
                
                if (!quiet) showLoading('识别中...');
                
                try {
                    // 每次识别前都根据当前框选计算最新图像坐标，避免旧缓存导致整图识别
                    // 优先使用已保存的图像坐标，避免在识别界面重算导致的1x1误差
                    let actualCropArea = savedImageCoordinates || null;
                    if (!actualCropArea) {
                        const cropHidden = cropStage && cropStage.classList && cropStage.classList.contains('hidden');
                        if (cropHidden) {
                            console.warn('裁剪容器不可见，跳过坐标重算，按整图或已保存坐标处理');
                        } else {
                            actualCropArea = calculateImageCoordinates(savedCropSelection || cropSelection);
                            console.log('计算得到的裁剪区域(像素坐标):', actualCropArea);
                        }
                    }
                    
                    // 如果仍无有效坐标，使用整图
                    if (!actualCropArea) {
                        const cropImage = document.getElementById('crop-image');
                        actualCropArea = {
                            x1: 0,
                            y1: 0,
                            x2: cropImage ? cropImage.naturalWidth || 1000 : 1000,
                            y2: cropImage ? cropImage.naturalHeight || 1000 : 1000,
                            active: true
                        };
                        console.log('使用整图坐标区域:', actualCropArea);
                    }
                    
                    console.log('使用的图像坐标区域:', actualCropArea);
                    
                    // 坐标取整：起点向下取整、终点向上取整，避免边界被截断
                    actualCropArea.x1 = Math.floor(actualCropArea.x1 || 0);
                    actualCropArea.y1 = Math.floor(actualCropArea.y1 || 0);
                    actualCropArea.x2 = Math.ceil(actualCropArea.x2 || 0);
                    actualCropArea.y2 = Math.ceil(actualCropArea.y2 || 0);

                    // 最小框选校验，避免发送过小或无效区域
                    const areaW = Math.max(0, actualCropArea.x2 - actualCropArea.x1);
                    const areaH = Math.max(0, actualCropArea.y2 - actualCropArea.y1);
                    if (areaW < 20 || areaH < 20) {
                        if (!quiet) { hideLoading(); showToast('选择区域过小或无效，请重新框选', false); }
                        return;
                    }

                    // 在UI提示当前裁剪坐标，便于确认与预览一致
                    if (!quiet) showToast(`裁剪坐标: x1=${actualCropArea.x1}, y1=${actualCropArea.y1}, x2=${actualCropArea.x2}, y2=${actualCropArea.y2}`);
                    
                    // 直接在前端裁剪并发送裁剪后的图像，彻底避免坐标换算误差
                    const croppedDataUrl = await getCroppedImageBase64(currentImage, actualCropArea);
                    const requestData = {
                        image: croppedDataUrl.split(',')[1],
                        crop_area: actualCropArea,
                        engine: window.__useCloudOCR ? 'doubao' : (window.__useRapidOCR ? 'rapid' : undefined)
                    };
                    // 不再区分 variant，本地统一走合并后的管线
                    console.log('发送到后端的裁剪区域:', requestData.crop_area);
                    
                    // 修改API端点为正确的后端地址
                    const API_BASE = window.__API_BASE || `${location.protocol}//${location.hostname}:5000`;
const response = await fetch(`${API_BASE}/api/ocr`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestData)
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        // 三种路由：云端、本地主结果、本地备选
                        if (window.__useCloudOCR && typeof resultTextCloud !== 'undefined' && resultTextCloud) {
                            resultTextCloud.value = data.text || '';
                        } else if (window.__useRapidOCR && typeof resultTextLocal2 !== 'undefined' && resultTextLocal2) {
                            // RapidOCR结果写入“本地识别2”
                            resultTextLocal2.value = data.text || '';
                        } else {
                            // 默认本地识别结果写入“本地识别”
                            if (typeof resultTextEnhanced !== 'undefined' && resultTextEnhanced) {
                                resultTextEnhanced.value = data.text || '';
                            }
                        }
                        resultPlaceholder.classList.add('hidden');
                        resultContainer.classList.remove('hidden');
                        updateTextStats();
                        if (!quiet) hideLoading();
                        if (!quiet) showToast('识别成功');
                    } else {
                        throw new Error(data.error || '识别失败');
                    }
                } catch (error) {
                    console.error('OCR错误:', error);
                    if (!quiet) { hideLoading(); showToast('OCR识别失败', false); }
                }
            }

            // 已移除表格识别功能            
            // 保存为Word文档（按目标）
            async function saveAsWordFor(targetId, label = 'origin') {
                const el = document.getElementById(targetId);
                const text = el ? (el.value || '') : '';
                if (!text.trim()) {
                    showToast('没有内容可保存', false);
                    return;
                }
                
                showLoading('正在生成Word文档...');
                
                try {
                    console.log('发送Word保存请求到/api/save-word');
                    const response = await fetch('/api/save-word', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text,
                            has_table: false
                        })
                    });
                    
                    if (response.ok) {
                        // 创建下载链接
                        const blob = await response.blob();
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `ocr_result_${label}_${new Date().getTime()}.docx`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        hideLoading();
                        showToast('Word文档保存成功');
                    } else {
                        throw new Error('生成Word文档失败');
                    }
                } catch (error) {
                    console.error('Word保存错误:', error);
                    hideLoading();
                    showToast('保存Word文档失败', false);
                    
                    // 降级方案：如果后端API不可用，使用前端创建简单的文本文件
                    const blob = new Blob([text], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `ocr_result_${label}_${new Date().getTime()}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }

            // 向后兼容（默认保存原始识别）
            async function saveAsWord() { return saveAsWordFor('result-text-enhanced', 'local'); }

            // 复制文本
            function copyText() {
                if (resultTextEnhanced) {
                    resultTextEnhanced.select();
                    document.execCommand('copy');
                    showToast('文本已复制到剪贴板');
                }
            }

            // 文本纠错（规则）
            async function fixText() {
                const text = resultTextEnhanced ? resultTextEnhanced.value.trim() : '';
                if (!text) return;
                showLoading('文本纠错中...');
                try {
                    const response = await fetch('/api/fix-text', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text })
                    });
                    const data = await response.json();
                    if (data.success) {
                        if (resultTextEnhanced) resultTextEnhanced.value = data.text;
                        updateTextStats();
                        showLoading();
                        hideLoading();
                        showToast('文本纠错完成');
                    } else {
                        throw new Error(data.error || '纠错失败');
                    }
                } catch (error) {
                    console.error('纠错错误:', error);
                    hideLoading();
                    showToast('文本纠错失败', false);
                }
            }

            // 文本纠错（LLM）
            async function fixTextLLM() {
                const text = resultTextEnhanced ? resultTextEnhanced.value.trim() : '';
                if (!text) return;
                showLoading('LLM纠错中...');
                try {
                    const response = await fetch('/api/fix-text', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text, use_llm: true })
                    });
                    const data = await response.json();
                    if (data.success) {
                        if (resultTextEnhanced) resultTextEnhanced.value = data.text;
                        updateTextStats();
                        hideLoading();
                        showToast('LLM纠错完成');
                    } else {
                        throw new Error(data.error || 'LLM纠错失败');
                    }
                } catch (error) {
                    console.error('LLM纠错错误:', error);
                    hideLoading();
                    showToast('LLM纠错失败', false);
                }
            }

            // LLM结构化抽取
            async function llmExtract() {
                const text = resultTextEnhanced ? resultTextEnhanced.value.trim() : '';
                if (!text) return;
                showLoading('结构化抽取中...');
                try {
                    const response = await fetch('/api/llm/extract', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text })
                    });
                    const data = await response.json();
                    hideLoading();
                    if (data.success) {
                        const jsonStr = JSON.stringify(data.data, null, 2);
                        showToast('抽取成功');
                        // 在文本下方创建/更新结果块
                        let panel = document.getElementById('llm-extract-panel');
                        if (!panel) {
                            panel = document.createElement('div');
                            panel.id = 'llm-extract-panel';
                            panel.className = 'mt-4 p-3 border border-slate-200 rounded-lg bg-slate-50';
                            const pre = document.createElement('pre');
                            pre.id = 'llm-extract-result';
                            pre.className = 'text-xs text-slate-700 whitespace-pre-wrap';
                            panel.appendChild(pre);
                            document.getElementById('result-container').appendChild(panel);
                        }
                        const pre = document.getElementById('llm-extract-result');
                        pre.textContent = jsonStr;
                    } else {
                        throw new Error(data.error || '抽取失败');
                    }
                } catch (error) {
                    console.error('结构化抽取错误:', error);
                    hideLoading();
                    showToast('结构化抽取失败', false);
                }
            }

            // 按目标导出TXT
            function downloadTextFor(targetId, label = 'origin') {
                const el = document.getElementById(targetId);
                const text = el ? (el.value || '') : '';
                if (!text.trim()) { showToast('没有内容可导出', false); return; }
                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `docvision_${label}_${new Date().getTime()}.txt`;
                a.click();
                URL.revokeObjectURL(url);
                showToast('文本已下载');
            }

            // 向后兼容（默认导出原始识别）
            function downloadText() { return downloadTextFor('result-text', 'origin'); }

            // 已移除导出CSV功能按钮及函数
            // 已移除导出HTML功能按钮及函数
            // 已移除视图切换功能
            // 导航栏滚动效果
            window.addEventListener('scroll', function() {
                if (window.scrollY > 10) {
                    navbar.classList.add('shadow-md');
                    navbar.classList.remove('shadow-sm');
                } else {
                    navbar.classList.remove('shadow-md');
                    navbar.classList.add('shadow-sm');
                }
            });

            // 处理拖拽上传
            function setupDragAndDrop() {
                if (!imageContainer) return;
                
                imageContainer.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    imageContainer.classList.add('border-primary');
                });
                
                imageContainer.addEventListener('dragleave', function() {
                    imageContainer.classList.remove('border-primary');
                });
                
                imageContainer.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    imageContainer.classList.remove('border-primary');
                    // 隐藏占位符并暂时禁止点击触发文件选择，避免拖拽后误触发
                    suppressUploadPrompt = true;
                    lastDropAt = Date.now();
                    if (uploadPlaceholder) uploadPlaceholder.classList.add('hidden');
                    
                    if (e.dataTransfer.files.length > 0) {
                        handleFileUpload(e.dataTransfer.files[0]);
                    }
                    // 给合成点击留出时间窗口，稍后再恢复点击行为
                    setTimeout(() => { suppressUploadPrompt = false; }, 500);
                });
            }

            // 初始化拖拽上传
            setupDragAndDrop();

            // 全局捕获点击，在抑制期间屏蔽一切点击事件传播与默认行为，防止重复弹窗
            document.addEventListener('click', function(e) {
                if (suppressUploadPrompt) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);

            // 安全地绑定事件监听器
            function safeBindEvent(elementId, event, callback) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.addEventListener(event, callback);
                }
            }
            
            // 重新上传图片
            function triggerReupload() {
                // 重置所有状态
                currentImage = null;
                currentRotation = 0;
                currentStep = 0;
                cropSelection = { x1: 0, y1: 0, x2: 0, y2: 0, active: false };
                suppressUploadPrompt = false;
                
                // 重置UI
                capturedImage.classList.add('hidden');
                uploadPlaceholder.classList.remove('hidden');
                rotateStage.classList.add('hidden');
                cropStage.classList.add('hidden');
                recognizeStage.classList.add('hidden');
                resultPlaceholder.classList.remove('hidden');
                resultContainer.classList.add('hidden');
                if (typeof resultTextEnhanced !== 'undefined' && resultTextEnhanced) resultTextEnhanced.value = '';
                if (typeof resultTextLocal2 !== 'undefined' && resultTextLocal2) resultTextLocal2.value = '';
                if (typeof resultTextCloud !== 'undefined' && resultTextCloud) resultTextCloud.value = '';
                updateTextStats();
                
                // 重置步骤指示器
                updateStepIndicator(0);
                
                // 触发文件选择
                triggerFileUpload();
            }

            // 回退自动应用的预览旋转（从第三步返回第二步时恢复原图）
            function revertAutoAppliedRotationIfNeeded() {
                try {
                    if (autoAppliedFromNext && prevImageBeforeAutoApply) {
                        currentImage = prevImageBeforeAutoApply;
                        capturedImage.src = currentImage;
                        currentRotation = prevRotationBeforeAutoApply;
                        // 清除CSS预览旋转
                        capturedImage.style.transform = 'none';
                        // 重置旋转控件
                        const rotateSlider = document.getElementById('rotate-slider');
                        const rotateInput = document.getElementById('rotate-input');
                        if (rotateSlider) rotateSlider.value = 0;
                        if (rotateInput) rotateInput.value = 0;
                        console.log('已恢复未旋转的原图');
                    }
                } catch (e) {
                    console.warn('恢复原图失败:', e);
                } finally {
                    autoAppliedFromNext = false;
                    prevImageBeforeAutoApply = null;
                }
            }

            // 绑定所有事件监听器
            safeBindEvent('rotate-left', 'click', () => quickRotate(-90));
            safeBindEvent('rotate-right', 'click', () => quickRotate(90));
            // 已移除增强功能绑定
            safeBindEvent('retake', 'click', triggerReupload);
            // 新增：透视矫正按钮事件
            safeBindEvent('apply-perspective', 'click', applyPerspective);
            safeBindEvent('skip-perspective', 'click', () => enterRotateStage());
            safeBindEvent('clear-perspective-points', 'click', () => { window.perspectivePoints = []; const c = document.getElementById('perspective-canvas'); if (c) { const ctx = c.getContext('2d'); ctx && ctx.clearRect(0,0,c.width,c.height); } });
            safeBindEvent('start-ocr', 'click', () => { window.__useCloudOCR = false; window.__useRapidOCR = false; performOCR(false); });
safeBindEvent('start-ocr-rapid', 'click', () => { window.__useCloudOCR = false; window.__useRapidOCR = true; performOCR(false); });
safeBindEvent('start-ocr-doubao', 'click', () => { window.__useCloudOCR = true; window.__useRapidOCR = false; performOCR(false); });

            safeBindEvent('copy-text', 'click', copyText);
            safeBindEvent('fix-text', 'click', fixText);
            safeBindEvent('fix-text-llm', 'click', fixTextLLM);
            safeBindEvent('llm-extract', 'click', llmExtract);
            safeBindEvent('download-text', 'click', downloadText);
            // 分结果导出（TXT）
            safeBindEvent('download-text-original', 'click', () => downloadTextFor('result-text', 'origin'));
            safeBindEvent('download-text-enhanced', 'click', () => downloadTextFor('result-text-enhanced', 'enhanced'));
safeBindEvent('download-text-local2', 'click', () => downloadTextFor('result-text-local2', 'local2'));
safeBindEvent('download-text-cloud', 'click', () => downloadTextFor('result-text-cloud', 'cloud'));
            // 分结果导出（Word）
            safeBindEvent('save-as-word-original', 'click', () => saveAsWordFor('result-text', 'origin'));
            safeBindEvent('save-as-word-enhanced', 'click', () => saveAsWordFor('result-text-enhanced', 'enhanced'));
safeBindEvent('save-as-word-local2', 'click', () => saveAsWordFor('result-text-local2', 'local2'));
safeBindEvent('save-as-word-cloud', 'click', () => saveAsWordFor('result-text-cloud', 'cloud'));
            // 已移除表格相关事件绑定
            safeBindEvent('upload-file', 'click', triggerFileUpload);
            
            // 步骤切换按钮事件
            safeBindEvent('next-to-crop', 'click', enterCropStage);
            safeBindEvent('back-to-rotate', 'click', function() {
                revertAutoAppliedRotationIfNeeded();
                enterRotateStage();
            });
            safeBindEvent('back-to-perspective', 'click', function() {
                revertAutoAppliedRotationIfNeeded();
                enterPerspectiveStage();
            });
            safeBindEvent('back-to-upload', 'click', enterUploadStep);
            safeBindEvent('back-to-crop', 'click', function() {
                updateStepIndicator(4);
                document.getElementById('crop-stage')?.classList.remove('hidden');
                document.getElementById('recognize-stage')?.classList.add('hidden');
            });
            safeBindEvent('next-to-recognize', 'click', function() {
                // 点击即框选整张图像内容矩形（object-contain），忽略已有选区
                try {
                    const contRect = cropContainer.getBoundingClientRect();
                    const contW = Math.round(contRect.width);
                    const contH = Math.round(contRect.height);
                    const natW = cropImage.naturalWidth;
                    const natH = cropImage.naturalHeight;
                    // 统一缩放比例与内容尺寸
                    const scale = Math.min(contW / natW, contH / natH);
                    const contentW = Math.round(natW * scale);
                    const contentH = Math.round(natH * scale);
                    const offsetX = Math.round((contW - contentW) / 2);
                    const offsetY = Math.round((contH - contentH) / 2);
                    // 在容器坐标系中设置“整图内容矩形”选区
                    savedCropSelection = {
                        x1: offsetX,
                        y1: offsetY,
                        x2: offsetX + contentW,
                        y2: offsetY + contentH,
                        active: true
                    };
                    // 计算对应的原始图像坐标
                    savedImageCoordinates = calculateImageCoordinates(savedCropSelection);
                    console.log('点击框选全部区域，使用整图内容坐标:', savedImageCoordinates);
                } catch (e) {
                    console.warn('框选全部区域失败，回退为整图处理:', e);
                    savedCropSelection = null;
                    savedImageCoordinates = null;
                }
                // 合并步骤：不切换界面，直接刷新预览并执行识别
                recognizeStage.classList.remove('hidden');
                try { createCropPreview(); } catch (e) {}
                performOCR(false);
            });
            
            // 自定义旋转控件事件
            const rotateSlider = document.getElementById('rotate-slider');
            const rotateInput = document.getElementById('rotate-input');
            const applyRotationBtn = document.getElementById('apply-rotation');
            
            if (rotateSlider && rotateInput) {
                // 控件值表示“目标累计角度”，预览应抵消当前累计角度，使视觉与目标一致
                const onSliderInput = () => {
                    const value = parseInt(rotateSlider.value) || 0;
                    rotateInput.value = value;
                    previewRotate(value - currentRotation);
                };
                rotateSlider.addEventListener('input', onSliderInput, { passive: true });
                // 兼容部分浏览器：拖动过程中也连续更新
                rotateSlider.addEventListener('pointerdown', () => {
                    const moveHandler = () => onSliderInput();
                    const upHandler = () => {
                        window.removeEventListener('pointermove', moveHandler);
                        window.removeEventListener('pointerup', upHandler);
                    };
                    window.addEventListener('pointermove', moveHandler, { passive: true });
                    window.addEventListener('pointerup', upHandler, { passive: true });
                }, { passive: true });
                
                rotateInput.addEventListener('input', function() {
                    // 验证输入范围
                    let value = parseInt(this.value);
                    if (isNaN(value)) value = 0;
                    if (value < -359) value = -359;
                    if (value > 359) value = 359;
                    this.value = value;
                    rotateSlider.value = value;
                    previewRotate(value - currentRotation);
                }, { passive: true });
                
                if (applyRotationBtn) {
                    applyRotationBtn.addEventListener('click', async function() {
                        const desired = parseInt(rotateInput.value) || 0; // 目标累计角度
                        let delta = desired - currentRotation;            // 仅按增量应用
                        // 规范化到[-360, 360]
                        if (!isNaN(delta)) {
                            delta = ((delta % 360) + 360) % 360; // -> [0,360)
                            if (delta > 180) delta -= 360;       // -> [-180,180]
                        }
                        if (Math.abs(delta) < 0.1) {
                            showToast('角度未改变');
                            return;
                        }
                        await applyRotation(delta);
                        // 应用后将控件更新为新的累计角度
                        rotateSlider.value = currentRotation;
                        rotateInput.value = currentRotation;
                        // 应用后清除CSS预览（回到零预览偏移）
                        capturedImage.style.transform = `rotate(${currentRotation}deg)`;
                    });
                }
            }
            
            // 绑定保存为Word文档事件
            safeBindEvent('save-as-word', 'click', saveAsWord);
            
            // 点击上传区域触发文件选择
            if (uploadPlaceholder) {
                uploadPlaceholder.addEventListener('click', function(e) {
                    if (suppressUploadPrompt) {
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }
                    triggerFileUpload();
                });
            }
            
            if (imageContainer) {
                imageContainer.addEventListener('click', function(e) {
                    // 只有在显示上传占位符时才触发上传
                    if (uploadPlaceholder && !uploadPlaceholder.classList.contains('hidden') && !suppressUploadPrompt) {
                        triggerFileUpload();
                    }
                });
            }
            
            // 文本区域变化事件
            if (resultText) {
                resultText.addEventListener('input', updateTextStats);
            }
            if (resultTextEnhanced) {
                resultTextEnhanced.addEventListener('input', updateTextStats);
            }
            if (typeof resultTextLocal2 !== 'undefined' && resultTextLocal2) {
                resultTextLocal2.addEventListener('input', updateTextStats);
            }
            if (typeof resultTextCloud !== 'undefined' && resultTextCloud) {
                resultTextCloud.addEventListener('input', updateTextStats);
            }
            });
    </script>
</body>
</html>